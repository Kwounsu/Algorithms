import sys
input = sys.stdin.readline

n, c = map(int, input().split())
m = int(input())
info = sorted([list(map(int, input().split())) for _ in range(m)], key=lambda x:(x[1],x[0]))

ans = 0
box = [0] * n

for a, b, q in info:
    # 구간 내 가장 많이 적재된 양
    box_cnt = max(box[a:b])

    # 트럭에 추가 가능한 양
    empty_space = min(q, c - box_cnt)
    ans += empty_space

    # 해당 구간 추가 적재
    for i in range(a, b):
        box[i] += empty_space

print(ans)

"""
info: [[1, 2, 30], [3, 4, 40], [2, 5, 70], [1, 6, 40], [5, 6, 60]]

box, empty_space:
[0, 30, 0, 0, 0, 0] 30
[0, 30, 0, 40, 0, 0] 40
[0, 30, 20, 60, 20, 0] 20
[0, 30, 20, 60, 20, 0] 0
[0, 30, 20, 60, 20, 60] 60

explain:
s에서 택배꾸러미를 받아서 e에서 택배를 내려놓는다고 할때
s에서부터 e-1까지 해당 택배꾸러미를 계속 들고 있어야 합니다. (e는 내려놓는곳이니까 제외)

해당 택배꾸러미의 용량을 w라고 하면 s부터 e까지는 택배를 기본 여유용량 C에서 w만큼 뺀 것.
즉, 예를 들면 원래 가방용량이 40이고 s=2 e=4라고 하고 들고다닐 택배꾸러미 용량w=20이라고 하면 (택배를 주고받는 곳이 6개 있다고 가정)
1  2  3  4  5  6
40 20 20 40 40 40 (각 지점에서의 가방의 여유용량)

그럼 다음번에 1-4구간에서 택배용량이 30만큼 되는걸 나르려고 해도 2-3구간의 여유용량이 20밖에 되지 않으므로 20만큼만 나를 수 있다.

이러한 알고리즘이 가능하게 된 것은 도착지점을 기준으로 오름차순 정렬을 하기 때문(두번째 우선순위는 출발지점을 기준 오름차순 정렬)
그니까 이 문제는 도착지점이 1쪽에 가까울수록, 즉 택배를 어디서 받았든간에(출발지점이 어떻든간에) 1에 가까운 도착지점에 택배를 내릴 수록 더 많은 택배를 실어날을 수 있습니다.
"""
